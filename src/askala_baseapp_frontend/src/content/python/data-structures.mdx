# Python Data Structures

Python provides several built-in data structures that help you organize and manipulate data efficiently. Understanding these is crucial for effective Python programming.

## Lists

Lists are ordered, mutable collections that can store items of different types.

### Creating Lists

```python
# Empty list
empty_list = []
numbers = list()

# List with initial values
fruits = ["apple", "banana", "orange", "grape"]
mixed = [1, "hello", 3.14, True]
nested = [[1, 2], [3, 4], [5, 6]]
```

### List Operations

```python
fruits = ["apple", "banana", "orange"]

# Adding elements
fruits.append("grape")           # Add to end
fruits.insert(1, "mango")        # Insert at index 1
fruits.extend(["kiwi", "peach"]) # Add multiple items

print(fruits)  # ['apple', 'mango', 'banana', 'orange', 'grape', 'kiwi', 'peach']

# Accessing elements
first_fruit = fruits[0]          # First element
last_fruit = fruits[-1]          # Last element
slice_fruits = fruits[1:4]       # Elements from index 1 to 3

# Modifying elements
fruits[0] = "pineapple"          # Change first element

# Removing elements
fruits.remove("banana")          # Remove by value
popped = fruits.pop()            # Remove and return last element
del fruits[1]                    # Remove by index
```

### List Methods and Functions

```python
numbers = [3, 1, 4, 1, 5, 9, 2, 6]

# Useful methods
numbers.sort()                   # Sort in place
numbers.reverse()                # Reverse in place
count = numbers.count(1)         # Count occurrences
index = numbers.index(4)         # Find index of value

# Useful functions
length = len(numbers)            # Get length
maximum = max(numbers)           # Get maximum value
minimum = min(numbers)           # Get minimum value
total = sum(numbers)             # Get sum
```

## Dictionaries

Dictionaries store key-value pairs and are unordered (Python 3.7+ maintains insertion order).

### Creating Dictionaries

```python
# Empty dictionary
empty_dict = {}
person = dict()

# Dictionary with initial values
student = {
    "name": "Alice",
    "age": 20,
    "grade": "A",
    "courses": ["Math", "Physics", "Chemistry"]
}

# Using dict() constructor
coordinates = dict(x=10, y=20, z=30)
```

### Dictionary Operations

```python
student = {"name": "Alice", "age": 20, "grade": "A"}

# Accessing values
name = student["name"]           # Direct access
age = student.get("age")         # Safe access
height = student.get("height", "Unknown")  # With default value

# Adding/Modifying values
student["major"] = "Computer Science"  # Add new key
student["age"] = 21                    # Modify existing key
student.update({"gpa": 3.8, "year": 2})  # Update multiple keys

# Removing items
del student["grade"]             # Remove specific key
popped_value = student.pop("age", None)  # Remove and return value
student.clear()                  # Remove all items
```

### Dictionary Methods

```python
student = {"name": "Alice", "age": 20, "major": "CS"}

# Getting keys, values, and items
keys = student.keys()            # dict_keys(['name', 'age', 'major'])
values = student.values()        # dict_values(['Alice', 20, 'CS'])
items = student.items()          # dict_items([('name', 'Alice'), ...])

# Checking existence
has_name = "name" in student     # True
has_grade = "grade" in student   # False

# Iterating
for key in student:
    print(f"{key}: {student[key]}")

for key, value in student.items():
    print(f"{key}: {value}")
```

## Sets

Sets are unordered collections of unique elements.

### Creating Sets

```python
# Empty set
empty_set = set()  # Note: {} creates an empty dict, not set

# Set with initial values
colors = {"red", "green", "blue"}
numbers = set([1, 2, 3, 2, 1])  # Duplicates automatically removed
```

### Set Operations

```python
colors = {"red", "green", "blue"}

# Adding elements
colors.add("yellow")             # Add single element
colors.update(["purple", "orange"])  # Add multiple elements

# Removing elements
colors.remove("red")             # Remove (raises error if not found)
colors.discard("pink")           # Remove (no error if not found)
popped = colors.pop()            # Remove and return arbitrary element

# Set operations
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}

union = set1 | set2              # {1, 2, 3, 4, 5, 6}
intersection = set1 & set2       # {3, 4}
difference = set1 - set2         # {1, 2}
symmetric_diff = set1 ^ set2     # {1, 2, 5, 6}
```

## Tuples

Tuples are ordered, immutable collections.

### Creating Tuples

```python
# Empty tuple
empty_tuple = ()
single_item = (42,)              # Note the comma for single item

# Tuple with multiple items
coordinates = (10, 20)
rgb_color = (255, 128, 0)
mixed_tuple = (1, "hello", 3.14, True)
```

### Tuple Operations

```python
point = (10, 20, 30)

# Accessing elements
x = point[0]                     # First element
y = point[1]                     # Second element
z = point[-1]                    # Last element

# Tuple unpacking
x, y, z = point                  # Assign to multiple variables
first, *rest = (1, 2, 3, 4, 5)  # first=1, rest=[2, 3, 4, 5]

# Tuple methods
numbers = (1, 2, 3, 2, 1)
count = numbers.count(2)         # Count occurrences
index = numbers.index(3)         # Find index of value
```

## Practical Examples

### Student Grade Management

```python
# Using different data structures together
students = [
    {"name": "Alice", "grades": [85, 92, 78, 96]},
    {"name": "Bob", "grades": [79, 85, 88, 82]},
    {"name": "Charlie", "grades": [92, 88, 95, 90]}
]

# Calculate average grades
for student in students:
    name = student["name"]
    grades = student["grades"]
    average = sum(grades) / len(grades)
    print(f"{name}: {average:.2f}")

# Find unique grades across all students
all_grades = set()
for student in students:
    all_grades.update(student["grades"])

print(f"Unique grades: {sorted(all_grades)}")
```

### Word Frequency Counter

```python
text = "the quick brown fox jumps over the lazy dog the fox is quick"
words = text.split()

# Count word frequencies using dictionary
word_count = {}
for word in words:
    word_count[word] = word_count.get(word, 0) + 1

print("Word frequencies:")
for word, count in word_count.items():
    print(f"{word}: {count}")

# Find most common words
max_count = max(word_count.values())
most_common = [word for word, count in word_count.items() if count == max_count]
print(f"Most common words: {most_common}")
```

## Best Practices

1. **Choose the Right Data Structure**:
   - Use lists for ordered, mutable sequences
   - Use tuples for ordered, immutable sequences
   - Use dictionaries for key-value mappings
   - Use sets for unique collections

2. **Performance Considerations**:
   - Dictionary and set lookups are O(1) on average
   - List searches are O(n)
   - Use sets for membership testing with large datasets

3. **Memory Usage**:
   - Tuples use less memory than lists
   - Sets and dictionaries have overhead for hash tables

## Practice Exercises

1. **Contact Book**: Create a dictionary-based contact book with names as keys and phone numbers as values.

2. **Shopping Cart**: Implement a shopping cart using lists and dictionaries to store items and their quantities.

3. **Set Operations**: Given two lists of student names, find students who are in both classes, only in the first class, and only in the second class.

Try implementing these exercises to solidify your understanding of Python data structures!